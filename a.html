<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rocket Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: radial-gradient(ellipse at center, #222 60%, #444 100%);
      overflow: hidden;
    }
    body {
      width: 100vw;
      height: 100vh;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: linear-gradient(to bottom, #222 0%, #1a2a3a 100%);
      display: block;
      margin: 0 auto;
      image-rendering: pixelated;
      box-shadow: 0 0 60px 30px #ffe066;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      aspect-ratio: 2 / 3;
      touch-action: none;
      border-radius: 18px;
      border: 2px solid #ffe066;
    }
    #restartBtn, #difficultyBtn {
      position: absolute;
      left: 50%;
      transform: translate(-50%, 0);
      padding: 16px 32px;
      font-size: 1.2em;
      background: #ffe066;
      color: #222;
      border: none;
      border-radius: 8px;
      box-shadow: 0 2px 8px #2224;
      display: none;
      z-index: 10;
    }
    #restartBtn { top: 60%; }
    #difficultyBtn { top: 70%; }
    #highScoreDisplay {
      position: absolute;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      color: #ffe066;
      font-size: 1.1em;
      font-family: Arial, sans-serif;
      text-shadow: 1px 1px 4px #222;
      z-index: 10;
      background: rgba(34,34,34,0.7);
      padding: 4px 16px;
      border-radius: 8px;
      border: 1px solid #ffe066;
      display: block;
    }
  </style>
</head>
<body>
  <div id="highScoreDisplay"></div>
  <button id="restartBtn">Restart</button>
  <button id="difficultyBtn">Difficulty: Easy</button>
  <canvas id="game"></canvas>
  <script>
    // Difficulty settings (now with Hardcore)
    const difficulties = [
      { name: "Easy", bombSpeed: 4, bombSpawn: 60, coinSpeed: 3, coinSpawn: 45, enemyBulletSpeed: 7 },
      { name: "Medium", bombSpeed: 6, bombSpawn: 45, coinSpeed: 5, coinSpawn: 35, enemyBulletSpeed: 9 },
      { name: "Hard", bombSpeed: 8, bombSpawn: 32, coinSpeed: 6, coinSpawn: 28, enemyBulletSpeed: 12 },
      { name: "Hardcore", bombSpeed: 12, bombSpawn: 18, coinSpeed: 8, coinSpawn: 18, enemyBulletSpeed: 18 }
    ];
    let difficultyIndex = 0;
    let currentDifficulty = difficulties[difficultyIndex];

    // High score per difficulty
    function getHighScoreKey() {
      return "rocketHighScore_" + currentDifficulty.name;
    }
    let highScore = parseInt(localStorage.getItem(getHighScoreKey()) || "0");
    function updateHighScoreDisplay() {
      document.getElementById("highScoreDisplay").textContent =
        `High Score: ${highScore} (${currentDifficulty.name})`;
    }
    updateHighScoreDisplay();

    // Responsive canvas setup for mobile ratio (2:3)
    function resizeCanvas() {
      const canvas = document.getElementById('game');
      let w = window.innerWidth;
      let h = window.innerHeight;
      // Maintain 2:3 aspect ratio
      if (w / h > 2 / 3) {
        w = h * 2 / 3;
      } else {
        h = w * 3 / 2;
      }
      canvas.width = w;
      canvas.height = h;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Game variables
    let frames = 0;
    let gameOver = false;

    // Rocket
    const rocket = {
      w: 38,
      h: 56,
      get x() { return this._x ?? canvas.width / 2 - this.w / 2; },
      set x(val) { this._x = val; },
      get y() { return this._y ?? canvas.height - 100; },
      set y(val) { this._y = val; },
      vx: 0,
      speed: 5,
      bullets: [],
      bulletSpeed: 10,
      draw() {
        ctx.save();
        ctx.translate(this.x + this.w / 2, this.y + this.h / 2);

        // Rocket body (gradient for realism)
        let grad = ctx.createLinearGradient(0, -this.h / 2, 0, this.h / 2);
        grad.addColorStop(0, "#f1c40f");
        grad.addColorStop(1, "#e67e22");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(0, -this.h / 2);
        ctx.lineTo(this.w / 2, this.h / 2);
        ctx.lineTo(-this.w / 2, this.h / 2);
        ctx.closePath();
        ctx.fill();

        // Window (glass effect)
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = "#3498db";
        ctx.beginPath();
        ctx.ellipse(0, -this.h / 4, 10, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Gun barrel (metallic)
        ctx.save();
        ctx.strokeStyle = "#bbb";
        ctx.lineWidth = 7;
        ctx.beginPath();
        ctx.moveTo(0, -this.h / 2);
        ctx.lineTo(0, -this.h / 2 - 22);
        ctx.stroke();
        ctx.restore();

        // Jet flames (animated)
        ctx.save();
        ctx.globalAlpha = 0.7;
        let flameColors = ["#ffec80", "#ff9800", "#ff3c00"];
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = flameColors[i];
          ctx.beginPath();
          ctx.moveTo(-10 + i * 7, this.h / 2);
          ctx.lineTo(0, this.h / 2 + 26 + Math.random() * 10);
          ctx.lineTo(10 - i * 7, this.h / 2);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        ctx.restore();

        // Draw bullets
        for (let bullet of this.bullets) {
          drawRocketBullet(bullet.x, bullet.y);
        }
      },
      update() {
        this.x += this.vx;
        // Boundaries
        if (this.x < 0) this.x = 0;
        if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
        // Update bullets
        for (let i = 0; i < this.bullets.length; i++) {
          this.bullets[i].y -= this.bulletSpeed;
          if (this.bullets[i].y < -12) {
            this.bullets.splice(i, 1);
            i--;
          }
        }
      },
      fire() {
        this.bullets.push({
          x: this.x + this.w / 2 - 2,
          y: this.y - 8 - 22
        });
      },
      reset() {
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - 100;
        this.vx = 0;
        this.bullets = [];
      }
    };

    // Rocket bullet (glow effect)
    function drawRocketBullet(x, y) {
      ctx.save();
      ctx.shadowColor = "#fff";
      ctx.shadowBlur = 12;
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, 5, 18);
      ctx.restore();
    }

    // Coins
    const coins = {
      items: [],
      radius: 14,
      get speed() { return currentDifficulty.coinSpeed; },
      get spawnRate() { return currentDifficulty.coinSpawn; },
      coinsPerSpawn: 2,
      draw() {
        for (let coin of this.items) {
          drawCoin(coin.x, coin.y, this.radius);
        }
      },
      update() {
        if (frames % this.spawnRate === 0) {
          let gapY = -this.radius * 2;
          let minX = 30, maxX = canvas.width - 30 - this.radius * 2;
          for (let c = 0; c < this.coinsPerSpawn; c++) {
            let x = minX + Math.random() * (maxX - minX);
            this.items.push({ x, y: gapY, collected: false });
          }
        }
        for (let i = 0; i < this.items.length; i++) {
          let coin = this.items[i];
          coin.y += this.speed;
          // Collision with rocket
          let cx = coin.x + this.radius, cy = coin.y + this.radius;
          let rx = rocket.x, ry = rocket.y, rw = rocket.w, rh = rocket.h;
          let closestX = Math.max(rx, Math.min(cx, rx + rw));
          let closestY = Math.max(ry, Math.min(cy, ry + rh));
          let dx = cx - closestX, dy = cy - closestY;
          if (dx * dx + dy * dy < this.radius * this.radius) {
            score.value += 5;
            this.items.splice(i, 1);
            i--;
            continue;
          }
          if (coin.y > canvas.height) {
            this.items.splice(i, 1);
            i--;
          }
        }
      },
      reset() {
        this.items = [];
      }
    };

    // Bomb Obstacles (fighter planes)
    const bombs = {
      items: [],
      radius: 22,
      get speed() { return currentDifficulty.bombSpeed; },
      get spawnRate() { return currentDifficulty.bombSpawn; },
      draw() {
        for (let bomb of this.items) {
          drawFighterPlane(bomb.x, bomb.y, this.radius);
        }
      },
      update() {
        if (frames % this.spawnRate === 0) {
          let minX = 30, maxX = canvas.width - 30 - this.radius * 2;
          let x = minX + Math.random() * (maxX - minX);
          this.items.push({ x, y: -this.radius * 2, fireCooldown: Math.floor(Math.random() * 30) + 30 });
        }
        for (let i = 0; i < this.items.length; i++) {
          let bomb = this.items[i];
          bomb.y += this.speed + Math.random() * 2;
          // Fighter plane fires
          bomb.fireCooldown--;
          if (bomb.fireCooldown <= 0) {
            enemyBullets.items.push({
              x: bomb.x + this.radius,
              y: bomb.y + this.radius * 2
            });
            bomb.fireCooldown = Math.floor(Math.random() * 40) + 30;
          }
          // Collision with rocket bullets
          for (let j = 0; j < rocket.bullets.length; j++) {
            let bullet = rocket.bullets[j];
            let bx = bomb.x + this.radius, by = bomb.y + this.radius;
            let cx = bullet.x + 2, cy = bullet.y + 9;
            let dx = bx - cx, dy = by - cy;
            if (dx * dx + dy * dy < this.radius * this.radius) {
              rocket.bullets.splice(j, 1);
              this.items.splice(i, 1);
              score.value += 10;
              i--;
              break;
            }
          }
          // Collision with rocket
          let bx = bomb.x + this.radius, by = bomb.y + this.radius;
          let rx = rocket.x, ry = rocket.y, rw = rocket.w, rh = rocket.h;
          let closestX = Math.max(rx, Math.min(bx, rx + rw));
          let closestY = Math.max(ry, Math.min(by, ry + rh));
          let dx = bx - closestX, dy = by - closestY;
          if (dx * dx + dy * dy < this.radius * this.radius) {
            gameOver = true;
            this.items.splice(i, 1);
            i--;
            continue;
          }
          if (bomb.y > canvas.height) {
            this.items.splice(i, 1);
            i--;
          }
        }
      },
      reset() {
        this.items = [];
      }
    };

    // Enemy Bullets (red laser)
    const enemyBullets = {
      items: [],
      get speed() { return currentDifficulty.enemyBulletSpeed; },
      draw() {
        for (let b of this.items) {
          drawEnemyBullet(b.x, b.y);
        }
      },
      update() {
        for (let i = 0; i < this.items.length; i++) {
          let b = this.items[i];
          b.y += this.speed;
          let rx = rocket.x, ry = rocket.y, rw = rocket.w, rh = rocket.h;
          if (
            b.x > rx && b.x < rx + rw &&
            b.y + 12 > ry && b.y < ry + rh
          ) {
            gameOver = true;
            this.items.splice(i, 1);
            i--;
            continue;
          }
          if (b.y > canvas.height) {
            this.items.splice(i, 1);
            i--;
          }
        }
      },
      reset() {
        this.items = [];
      }
    };

    // Helper function to draw a coin (shine and shadow)
    function drawCoin(x, y, r) {
      ctx.save();
      let grad = ctx.createRadialGradient(x + r, y + r, r * 0.3, x + r, y + r, r);
      grad.addColorStop(0, "#fffbe6");
      grad.addColorStop(0.7, "#FFD700");
      grad.addColorStop(1, "#B8860B");
      ctx.beginPath();
      ctx.arc(x + r, y + r, r, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.shadowColor = "#FFEB3B";
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.strokeStyle = "#B8860B";
      ctx.lineWidth = 3;
      ctx.stroke();
      // Shine
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(x + r, y + r, r * 0.5, Math.PI * 1.2, Math.PI * 1.7);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Helper function to draw a fighter plane (more realistic)
    function drawFighterPlane(x, y, r) {
      ctx.save();
      ctx.translate(x + r, y + r);

      // Body
      let grad = ctx.createLinearGradient(0, -r, 0, r);
      grad.addColorStop(0, "#8ecae6");
      grad.addColorStop(1, "#023047");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, r); // nose (bottom)
      ctx.lineTo(r * 0.5, -r * 0.7); // right tail
      ctx.lineTo(0, -r * 0.4); // rear
      ctx.lineTo(-r * 0.5, -r * 0.7); // left tail
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#1a2a3a";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Cockpit
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = "#b3e0ff";
      ctx.beginPath();
      ctx.ellipse(0, r * 0.5, r * 0.22, r * 0.32, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Left wing
      ctx.fillStyle = "#2d4d6a";
      ctx.beginPath();
      ctx.moveTo(-r * 0.5, -r * 0.1);
      ctx.lineTo(-r * 1.1, -r * 0.5);
      ctx.lineTo(-r * 0.3, -r * 0.5);
      ctx.closePath();
      ctx.fill();

      // Right wing
      ctx.beginPath();
      ctx.moveTo(r * 0.5, -r * 0.1);
      ctx.lineTo(r * 1.1, -r * 0.5);
      ctx.lineTo(r * 0.3, -r * 0.5);
      ctx.closePath();
      ctx.fill();

      // Tail fin
      ctx.fillStyle = "#4a8edb";
      ctx.beginPath();
      ctx.moveTo(0, -r * 0.4);
      ctx.lineTo(r * 0.13, -r * 0.9);
      ctx.lineTo(-r * 0.13, -r * 0.9);
      ctx.closePath();
      ctx.fill();

      // Engine glow
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.shadowColor = "#ff9800";
      ctx.shadowBlur = 12;
      ctx.fillStyle = "#ff9800";
      ctx.beginPath();
      ctx.arc(0, r, 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.restore();
    }

    // Enemy bullet (red laser with glow)
    function drawEnemyBullet(x, y) {
      ctx.save();
      ctx.shadowColor = "#ff4444";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "#ff4444";
      ctx.fillRect(x - 2, y, 5, 18);
      ctx.restore();
    }

    // Score
    const score = {
      value: 0,
      draw() {
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = "#FFF";
        ctx.strokeStyle = "#222";
        ctx.font = "bold 40px Arial";
        ctx.textAlign = "center";
        ctx.fillText(this.value, canvas.width / 2, 60);
        ctx.strokeText(this.value, canvas.width / 2, 60);
        ctx.restore();
      },
      reset() {
        this.value = 0;
      }
    };

    // Start automatic firing
    let fireInterval = setInterval(() => {
      if (!gameOver) rocket.fire();
    }, 120);

    // Control
    document.addEventListener("keydown", function (e) {
      if (e.code === "ArrowLeft") {
        rocket.vx = -rocket.speed;
      }
      if (e.code === "ArrowRight") {
        rocket.vx = rocket.speed;
      }
      if ((e.code === "Space" || e.code === "ArrowUp") && gameOver) {
        restartGame();
      }
    });
    document.addEventListener("keyup", function (e) {
      if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
        rocket.vx = 0;
      }
    });

    // Mobile touch controls
    let touchX = null;
    canvas.addEventListener("touchstart", function (e) {
      if (e.touches.length > 0) {
        touchX = e.touches[0].clientX;
      }
    });
    canvas.addEventListener("touchmove", function (e) {
      if (e.touches.length > 0) {
        let currentX = e.touches[0].clientX;
        let delta = currentX - touchX;
        touchX = currentX;
        rocket.x += delta;
        if (rocket.x < 0) rocket.x = 0;
        if (rocket.x + rocket.w > canvas.width) rocket.x = canvas.width - rocket.w;
      }
    });
    canvas.addEventListener("touchend", function () {
      touchX = null;
    });

    // Mobile device tilt controls
    if (window.DeviceOrientationEvent) {
      window.addEventListener("deviceorientation", function (event) {
        let gamma = event.gamma;
        if (gamma !== null) {
          let normalized = Math.max(-30, Math.min(30, gamma));
          rocket.x = canvas.width / 2 - rocket.w / 2 + (normalized / 30) * (canvas.width / 2 - rocket.w / 2);
          if (rocket.x < 0) rocket.x = 0;
          if (rocket.x + rocket.w > canvas.width) rocket.x = canvas.width - rocket.w;
        }
      });
    }

    // Show restart button only on mobile
    function isMobile() {
      return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
    }
    const restartBtn = document.getElementById('restartBtn');
    const difficultyBtn = document.getElementById('difficultyBtn');
    if (isMobile()) {
      restartBtn.style.display = 'block';
      difficultyBtn.style.display = 'block';
    }

    // Difficulty button logic
    difficultyBtn.addEventListener('click', function () {
      difficultyIndex = (difficultyIndex + 1) % difficulties.length;
      currentDifficulty = difficulties[difficultyIndex];
      difficultyBtn.textContent = "Difficulty: " + currentDifficulty.name;
      highScore = parseInt(localStorage.getItem(getHighScoreKey()) || "0");
      updateHighScoreDisplay();
      restartGame();
    });

    // Restart logic for button
    restartBtn.addEventListener('click', function () {
      restartGame();
      restartBtn.style.display = 'none';
    });

    function restartGame() {
      rocket.reset();
      score.reset();
      coins.reset();
      bombs.reset();
      enemyBullets.reset();
      gameOver = false;
      clearInterval(fireInterval);
      fireInterval = setInterval(() => {
        if (!gameOver) rocket.fire();
      }, 120);
    }

    // Show button when game over (mobile only)
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background stars
      drawStars();

      bombs.draw();
      enemyBullets.draw();
      coins.draw();
      rocket.draw();
      score.draw();

      // Save high score per difficulty
      if (score.value > highScore) {
        highScore = score.value;
        localStorage.setItem(getHighScoreKey(), highScore);
        updateHighScoreDisplay();
      }

      if (gameOver) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, canvas.height / 2 - 80, canvas.width, 120);
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#ffe066";
        ctx.font = "bold 38px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2);
        ctx.font = "22px Arial";
        ctx.fillStyle = "#fff";
        ctx.fillText("Press Space or Restart", canvas.width / 2, canvas.height / 2 + 40);
        if (isMobile()) {
          restartBtn.style.display = 'block';
          difficultyBtn.style.display = 'block';
        }
        ctx.restore();
      } else {
        if (isMobile()) {
          restartBtn.style.display = 'none';
          difficultyBtn.style.display = 'block';
        }
      }
    }

    // Starfield background for realism
    const stars = [];
    function initStars() {
      stars.length = 0;
      for (let i = 0; i < 80; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 1.5 + 0.5,
          alpha: Math.random() * 0.5 + 0.5
        });
      }
    }
    function drawStars() {
      ctx.save();
      for (let s of stars) {
        ctx.globalAlpha = s.alpha;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    }
    initStars();

    function update() {
      if (!gameOver) {
        rocket.update();
        bombs.update();
        enemyBullets.update();
        coins.update();
      }
    }

    function loop() {
      update();
      draw();
      frames++;
      requestAnimationFrame(loop);
    }

    loop();

    // Re-center rocket and coins on resize
    window.addEventListener('resize', () => {
      rocket.reset();
      coins.reset();
      bombs.reset();
      enemyBullets.reset();
      score.reset();
      gameOver = false;
      initStars();
    });
  </script>
</body>
</html>
